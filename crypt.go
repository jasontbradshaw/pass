package pass

import (
	"bytes"
	"compress/flate"
	"compress/gzip"
	"crypto/aes"
	"crypto/hmac"
	"crypto/sha512"
	"fmt"
	"io/ioutil"

	"code.google.com/p/go.crypto/scrypt"
	"github.com/ugorji/go/codec"
)

// the current version of the encrypted blob format, and the one all new blobs
// will be created with.
const CurrentVersion version = 0

// alias types to prevent mixing up the otherwise-unlabeled simple types used
// all over the place.
type version int32
type meta []byte
type payload []byte

type aes256Key [32]byte
type aesIV [aes.BlockSize]byte
type salt32 [32]byte
type scryptN int32
type scryptP int32
type scryptR int32
type sha512Key [sha512.BlockSize]byte
type sha512Signature [sha512.Size]byte

// encode something using msgpack and return the encoded bytes.
// NOTE: pass the thing to be encoded in as a pointer!
func encodeMsgpack(thing interface{}) ([]byte, error) {
	var (
		out []byte
		mh  codec.MsgpackHandle
	)
	enc := codec.NewEncoderBytes(&out, &mh)
	err := enc.Encode(thing)
	if err != nil {
		return nil, err
	}

	return out, nil
}

// compress some data using the GZip algorithm and return it
func compressGzip(data []byte) ([]byte, error) {
	compressed := new(bytes.Buffer)
	writer, err := gzip.NewWriterLevel(compressed, flate.BestCompression)
	if err != nil {
		return nil, err
	}
	defer writer.Close()

	// compress our data
	writer.Write(data)

	return compressed.Bytes(), nil
}

// decompress some data compressed by the GZip algorithm
func decompressGzip(data []byte) ([]byte, error) {
	b := bytes.NewBuffer(data)
	reader, err := gzip.NewReader(b)
	if err != nil {
		return nil, err
	}
	defer reader.Close()

	// decompress our data
	result, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// get the signature of the given data as a byte array using SHA-512
//
// NOTE: we want the key to be no shorter than the hash algorithm's block size,
// otherwise it will be zero-padded. longer keys are hashed to obtain a key of
// the same size as the block size, so there'really no benefit in using a key
// size that's not equal to the block size of the hash algorithm. we just
// enforce the exact key size to keep things simple.
//
// see:
// * http://stackoverflow.com/a/12207647
// * http://en.wikipedia.org/wiki/Hash-based_message_authentication_code#Definition_.28from_RFC_2104.29
func signSHA512(data []byte, key sha512Key) (sha512Signature, error) {
	mac := hmac.New(sha512.New, key[:])
	mac.Write(data)

	// copy the unsized-array from the sum into a sized array
	var sig sha512Signature
	n := copy(sig[:], mac.Sum(nil))

	// ensure that we got a sum with the exact number of bytes we wanted
	if n != sha512.Size {
		return sha512Signature{}, fmt.Errorf(
			"Signature didn't contain the correct number of bytes (got: %d, expected: %d)",
			n, sha512.Size,
		)
	}

	return sig, nil
}

// return an erro if the given signature doesn't verify the given data
func verifySHA512(data []byte, suppliedSignature sha512Signature, key sha512Key) error {
	// sign the data ourselves
	computedSignature, err := signSHA512(data, key)
	if err != nil {
		return err
	}

	// signal an error if the computed signature doesn't match the given one.
	// notice that we securely compare the signatures to avoid timing attacks!
	if !hmac.Equal(suppliedSignature[:], computedSignature[:]) {
		return fmt.Errorf(
			"Signatures do not match:\n  supplied: %v\n  computed: %v",
			suppliedSignature, computedSignature,
		)
	}

	// return no error since the data authenticated correctly
	return nil
}

// given a password string and a salt, populate the given byte slices with the
// scrypt-generated bytes, in their respective orders.
func hashPasswordScrypt(password string, salt salt32, N scryptN, r scryptR, p scryptP, outputs ...[]byte) error {
	// NOTE: scrypt memory usage is approximately 128 * `N` * `r` bytes. since `p`
	// has little effect on memory usage, it can be used to tune the running time
	// of the algorithm.

	// ensure that all the encryption paramters meet minimum requirements
	if N <= 1 {
		return fmt.Errorf("N must be larger than one")
	} else if r <= 0 {
		return fmt.Errorf("r must be larger than zero")
	} else if p <= 0 {
		return fmt.Errorf("p must be larger than zero")
	}

	// calculate the number of bytes we need to generate overall
	size := 0
	for _, b := range outputs {
		size += len(b)
	}

	// generate the needed bytes. since scrypt is checking the sizes of the
	// parameter values for us, we don't need to do it ourselves (see:
	// http://code.google.com/p/go/source/browse/scrypt/scrypt.go?repo=crypto).
	hashed, err := scrypt.Key([]byte(password), salt[:], int(N), int(r), int(p), size)
	if err != nil {
		return err
	}

	// fill each output byte array with the generated hash bytes
	offset := 0
	for i, b := range outputs {
		count := len(b)

		// make sure we have enough bytes left to copy
		if offset+count > len(hashed)-1 {
			return fmt.Errorf("Too few hashed bytes were generated to fill all output byte slices")
		}

		n := copy(b, hashed[offset:count])
		if n != count {
			return fmt.Errorf(
				"Failed to copy enough bytes to fill output byte slice at index %d",
				i,
			)
		}

		// increase the offset
		offset += count
	}

	return nil
}

// encrypt some data using the given password
func Encrypt(data []byte, password string) ([]byte, error) {
	// NOTE: always use the latest encryption version's function here!
	return encrypt0(data, password)
}

// decrypt some data using the given password
func Decrypt(data []byte, password string) ([]byte, error) {
	// parse the data as a simple map so we can extract the version
	var (
		meta map[string]interface{}
		mh   codec.MsgpackHandle
	)

	dec := codec.NewDecoderBytes(data, &mh)
	err := dec.Decode(&meta)
	if err != nil {
		return nil, err
	}

	// ensure that the blob included a version
	versionInterface, ok := meta["Version"]
	if !ok {
		return nil, fmt.Errorf("Data includes no \"Version\" key")
	}

	// convert the version to the expected type
	version, ok := versionInterface.(version)
	if !ok {
		return nil, fmt.Errorf("Version could not be read as a version number")
	}

	// decrypt based on the indicated version
	switch version {
	default:
		// disallow all unrecognized versions
		return nil, fmt.Errorf("Unable to read file of version %d", version)

	// NOTE: add new versions as we create them!
	case 0:
		return decrypt0(data, password)
	}

	panic("This should be impossible!")
}
