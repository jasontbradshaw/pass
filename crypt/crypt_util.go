package crypt

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io/ioutil"

	"golang.org/x/crypto/scrypt"
	"github.com/ugorji/go/codec"
)

// Alias types to prevent mixing up the otherwise-unlabeled simple types used
// all over the place.
type aes128Key [16]byte      // 128 bits == use AES-128. This is required by GCM.
type aes128GCMNonce [12]byte // 12 bytes is the standard AES-GCM nonce size.
type salt128 [16]byte        // A 128-bit random salt value.
type scryptN int32
type scryptP int32
type scryptR int32

// This is a random number that serves to identify files encoded using any
// version of our encryption scheme.
type formatBytes [4]byte

var magicFormatBytes = formatBytes{0x4a, 0x1a, 0xb5, 0x52}

// The maximum size of our ciphertext. If it's longer than this, we will fail to
// correctly encode it and must throw an error.
const ciphertextMaxLength = 4294967295

// Encode something using msgpack and return the encoded bytes.
// NOTE: You should pass in the thing to be encoded as a pointer!
func encodeMsgpack(thingPointer interface{}) ([]byte, error) {
	var (
		out []byte
		mh  codec.MsgpackHandle
	)
	enc := codec.NewEncoderBytes(&out, &mh)
	err := enc.Encode(thingPointer)
	if err != nil {
		return nil, err
	}

	return out, nil
}

// Compress some data using the GZip algorithm and return it. We use the "best
// speed" version since we want this to be reasonably fast, but still compress
// the data to obfuscate it well and reduce payload size.
func compressGZip(data []byte) ([]byte, error) {
	compressed := new(bytes.Buffer)
	writer, err := gzip.NewWriterLevel(compressed, gzip.BestSpeed)
	if err != nil {
		return nil, err
	}

	// Compress our data.
	writer.Write(data)
	writer.Close()

	return compressed.Bytes(), nil
}

// Decompress some data compressed by the GZip algorithm.
func decompressGZip(data []byte) ([]byte, error) {
	b := bytes.NewBuffer(data)
	reader, err := gzip.NewReader(b)
	if err != nil {
		return nil, err
	}

	// Decompress our data.
	result, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	reader.Close()

	return result, nil
}

// Given some bytes, a salt, and some scrypt params, return a byte slice with
// the requested number of bytes.
func hashScrypt(data []byte, salt salt128, N scryptN, r scryptR, p scryptP, size int) ([]byte, error) {
	// NOTE: scrypt memory usage is approximately 128 * `N` * `r` bytes. Since `p`
	// has little effect on memory usage, it can be used to tune the running time
	// of the algorithm.

	// Ensure that all the encryption parameters meet minimum requirements.
	if N <= 1 {
		return nil, fmt.Errorf("N must be larger than one")
	} else if r <= 0 {
		return nil, fmt.Errorf("r must be larger than zero")
	} else if p <= 0 {
		return nil, fmt.Errorf("p must be larger than zero")
	}

	// Generate the needed bytes. Since scrypt is checking the sizes of the
	// parameter values for us, we don't need to do it ourselves (see:
	// http://code.google.com/p/go/source/browse/scrypt/scrypt.go?repo=crypto).
	return scrypt.Key(data, salt[:], int(N), int(r), int(p), size)
}

// Given some bytes, a salt, and some scrypt params, populate the given byte
// slices with the bytes generated by scrypt-hashing the input data using the
// given parameters. The slices are populated first-to-last, consuming the
// generated bytes first-to-last as they're populated.
func hashFillScrypt(N scryptN, r scryptR, p scryptP, salt salt128, data []byte, outputs ...[]byte) error {
	// Calculate the number of bytes we need to generate overall.
	size := 0
	for _, b := range outputs {
		size += len(b)
	}

	// Generate the exact number of bytes we need.
	hashed, err := hashScrypt(data, salt, N, r, p, size)
	if err != nil {
		return err
	}

	// Fill each output byte slice in turn with the generated bytes, in the order
	// the bytes and slices were given to us.
	offset := 0
	for i, b := range outputs {
		count := len(b)

		n := copy(b, hashed[offset:offset+count])
		if n != count {
			return fmt.Errorf(
				"Failed to copy enough bytes to fill output byte slice at index %d", i)
		}

		offset += count
	}

	return nil
}

// Builds a blob header compatible across all encryption versions. This consists
// of two concatenated msgpack values. The first is a several bytes marking this
// as our format. The second is an integer marking the version number used to
// encrypt the subsequent data. This data is returned as a byte array, along
// with an error if anything went wrong.
func buildHeaderBlob(version cryptVersionNumber) ([]byte, error) {
	magicBytes, err := encodeMsgpack(&magicFormatBytes)
	if err != nil {
		return nil, err
	}

	versionBytes, err := encodeMsgpack(&version)
	if err != nil {
		return nil, err
	}

	// Concatenate and return the resulting bytes.
	return append(magicBytes, versionBytes...), nil
}

// Given a decoder for a blob ostensibly compatible with this program, attempts
// to decode it and return its claimed version number. Does not attempt to
// verify that we support the given version number, only that we can obtain one
// in general.
func parseBlobVersion(decoder *codec.Decoder) (cryptVersionNumber, error) {
	// Attempt to decode the magic bytes the blob should start with. If this
	// fails, we have certainly been given something not of our file type.
	var format formatBytes
	err := decoder.Decode(&format)
	if err != nil {
		return -1, err
	}

	// Ensure the magic bytes match ours. If they don't, we got a msgpack blob
	// that doesn't contain the type of data we need. This is exceedingly
	// unlikely, but you never know what we'll be given!
	if !bytes.Equal(magicFormatBytes[:], format[:]) {
		return -1, fmt.Errorf(
			"Unrecognizable blob format. The data you're trying to access isn't marked as being the type this program can understand.",
		)
	}

	// Decode the version. If we can't read this, again we have a serious problem.
	var version cryptVersionNumber
	err = decoder.Decode(&version)
	if err != nil {
		return -1, err
	}

	return version, nil
}

// Same as `#parseBlobVersion`, but decodes directly from an array of bytes
// instead of from a given decoder.
func parseBlobVersionBytes(blob []byte) (cryptVersionNumber, error) {
	var mh codec.MsgpackHandle
	dec := codec.NewDecoderBytes(blob, &mh)
	return parseBlobVersion(dec)
}
